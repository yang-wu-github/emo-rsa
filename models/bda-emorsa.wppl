 // time webppl bda-emorsa.wppl --require webppl-csv --require ~/tools/webppl-sample-writer-fork --require emorsaUtils 1
 var args = process.argv
 var chain = last(args) // load index as last command line index


// HELPER FUNCTIONS
var df_semantics = dataFrame(csv.read("clean_semantics_params.csv"), ["state", "a","b"])
var df_goals = dataFrame(csv.read("clean_data_goals.csv"), ["response"])
var df_state = dataFrame(csv.read("clean_data_true_state.csv"), ["response"])

var states = levels(df_semantics, "state")
var semObjects = levels(df_semantics, "trial")
var semObjDict = {Bad: "bad", Good: "good", Pos: "smile", Neg: "frown"}


var model = function(){
  // global free parameters
  var speakerOptimality = uniformDrift({a: 0, b: 20, width: 2})

  // literal meaning parameters
  // prior is posterior after literal semantics task
  var literalMeanings = _.fromPairs(map(function(u){
    var utt_row = _.filter(df_semantics, {trial: u})
    var utt_emo = semObjDict[utt_row[0].trial]
    return [utt_emo, _.fromPairs(map(function(s){
      var utt_state_row = _.filter(utt_row, {state: s})[0]
      return [s, sample(Beta({a: utt_state_row.a, b: utt_state_row.b})) ]
    }, states))]
  }, semObjects))

  var parameters = { speakerOptimality, literalMeanings }

  foreach(emotions, function(emo){
    foreach(utterances, function(utt){

      // // MUNGE DATA
      // subset data by utt-emo condition
      var state_data = _.map(
        _.filter(df_state, {utt: utt, exp: emo}),
        "response")

      var socGoal_data = _.map(
        _.filter(df_goals, {utt: utt, exp: emo, question: "social goal"}),
        "response")

      var infGoal_data = _.map(
        _.filter(df_goals, {utt: utt, exp: emo, question: "informational goal"}),
        "response")

      // // GENERATE MODEL PREDICTIONS
      // run RSA model
      var modelPrediction = Ma2_UttInfEmoBal(utt, emo, parameters)

      // marginalize for specific task predictions
      var statePrediction = marginalize(modelPrediction, "state")
      var socGoalPrediction = marginalize(modelPrediction, "socGoal")
      var infGoalPrediction = marginalize(modelPrediction, "infGoal")

      // // OBSERVE DATA
      // display('state')
      // display(state_data)
      // observe state data
      mapData({data: state_data}, function(d){
        var scr = statePrediction.score(d)
        scr == -Infinity ? display(utt + " _ " + emo + " _ " + d) : null
        observe(statePrediction, d)
      })
      // display('soc goal')
      //
      // display(socGoal_data)

      // observe social goal data
      mapData({data: socGoal_data}, function(d){
        var scr = socGoalPrediction.score(d)
        scr == -Infinity ? display(utt + " _ " + emo + " _ " + d) : null
        observe(socGoalPrediction, d)
      })
      // display('inf goal')
      // display(infGoal_data)
      // observe informational goal data
      mapData({data: infGoal_data}, function(d){
        var scr = infGoalPrediction.score(d)
        scr == -Infinity ? display(utt + " _ " + emo + " _ " + d) : null
        observe(infGoalPrediction, d)
      })

      // // RECORD PREDICTIONS
      // record state predictions
      var stateSupport = statePrediction.support()
      foreach(stateSupport, function(s){
        query.add(["state", utt, emo, s], Math.exp(statePrediction.score(s)))
      })

      // record social goal predictions
      var socSupport = socGoalPrediction.support()
      foreach(socSupport, function(sg){
        query.add(["socGoal", utt, emo, sg], Math.exp(socGoalPrediction.score(sg)))
      })

      // record informational goal predictions
      var infSupport = infGoalPrediction.support()
      foreach(infSupport, function(ig){
        query.add(["infGoal", utt, emo, ig], Math.exp(infGoalPrediction.score(ig)))
      })

    })
  })

  query.add(["parameter", "speakerOptimality", "NA", "NA"], speakerOptimality)

  return query

}


var totalIterations = 100, lag =  0;
var samples = totalIterations/(lag + 1), burn = totalIterations / 2;

var outfile = 'test_bda-Ma2_UttInfEmoBal' +
  totalIterations+ '_burn' + burn +
  '_lag' + lag + '_chain' + chain + '.csv'

var header = "iter,parameter,utt,emo,state,val,score"
var callback = webpplSampleWriter.streamQueryCSV("bda_results/" + outfile, header);

Infer({model: model,
      samples: samples, burn: burn, lag: lag,
       method: 'incrementalMH',
       onlyMAP: true,
       verbose: T,
       verboseLag: totalIterations / 20,
       callbacks: [callback]
     });

"written to " + outfile;

// df_semantics

// var speakerOptimality = uniformDrift({a: 0, b: 20, width: 2})
//
// // literal meaning parameters
// // prior is posterior after literal semantics task
// var literalMeanings = _.fromPairs(map(function(u){
//   var utt_row = _.filter(df_semantics, {trial: u})
//   var utt_emo = semObjDict[utt_row[0].trial]
//   return [utt_emo, _.fromPairs(map(function(s){
//     var utt_state_row = _.filter(utt_row, {state: s})[0]
//     return [s, sample(Beta({a: utt_state_row.a, b: utt_state_row.b})) ]
//   }, states))]
// }, semObjects))
//


// display(parameters)
// displayDist(marginalize(Ma0_UttInfEmoNon("good", "smile", parameters), "state"))
